# This is a descriptive name for your workflow. It will appear in the Actions tab.
name: CI/CD Pipeline with Artifacts

# This section defines the triggers for the workflow.
# It will run on every push to the 'main' branch.
# 'workflow_dispatch' allows you to run it manually from the Actions tab.
on:
  push:
    branches: [ main ]
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel.
jobs:
  # The first job is 'build'. Its purpose is to compile/package the code.
  build:
    # The type of runner that the job will run on. 'ubuntu-latest' is a common choice.
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job.
    steps:
      # Step 1: Check out your repository's code so the job can access it.
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Simulate a build process.
      # In a real project, this would be `npm run build`, `mvn package`, `dotnet publish`, etc.
      # Here, we're just creating a 'dist' directory with some output files.
      - name: Simulate build process
        run: |
          echo "Starting the build process..."
          mkdir -p dist
          wget https://dlcdn.apache.org/maven/maven-3/3.9.11/binaries/apache-maven-3.9.11-bin.tar.gz -O dist/apache-maven-3.9.11-bin.tar.gz
          tar -xzvf dist/apache-maven-3.9.11-bin.tar.gz -C dist
          rm -rf dist/apache-maven-3.9.11-bin.tar.gz
          echo "<h1>My Awesome App</h1>" > dist/index.html
          echo "Build version: ${{ github.sha }}" > dist/version.txt
          echo "Build process complete. Files are in the 'dist' directory."

      # Step 3: Upload the build output as an artifact.
      # This makes the 'dist' directory available to other jobs in this workflow.
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          # The name for the artifact. This will be used to download it later.
          name: web-app-package
          # The path to the file or directory to upload.
          path: ./dist

  # The second job is 'deploy'. It depends on the 'build' job completing successfully.
  deploy:
    # 'needs: build' ensures that this 'deploy' job will only run after the 'build' job has succeeded.
    needs: build

    # The type of runner that this job will run on. It's a fresh machine, separate from the 'build' runner.
    runs-on: ubuntu-latest

    # Optional: Define the deployment environment for added protection rules and secrets.
    environment:
      name: production
      url: https://example.com # Replace with your deployment URL

    steps:
      # Step 1: Download the artifact that was uploaded in the 'build' job.
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          # The name must exactly match the name used in the 'upload-artifact' step.
          name: web-app-package
          # Optional: specify a path to download to. If omitted, it downloads to the current directory.

      # Step 2: Verify the downloaded files and simulate a deployment.
      # In a real-world scenario, you would use tools like `rsync`, `scp`, or a cloud provider's CLI
      # to push these files to your server or cloud service.
      - name: Simulate deployment
        run: |
          echo "Starting deployment..."
          echo "Listing files in the workspace to verify download:"         
         
          ls -la
          echo "---"
          echo "Displaying content of version.txt:"
          cat version.txt
          echo "---"
          echo "Deployment to production environment was successful!"
